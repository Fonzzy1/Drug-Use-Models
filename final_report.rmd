---
title : 'Modeling Drug Use in Comunities'
author:  'Alfie Chadwick, Kevin Dai, Cheysovalantis Thomopoulos'
---

# Introduction
For years, policymakers have been asking why and how do drugs travel through the community and what can they do to work minimise the harm they potentially  cause. In this paper, we aim to understand how drug use and addiction develops in a community and what factors can be tweaked to alter the short term and long term distributions of drug use and addiction in the community.


// Add in past research

\newpage

# Method

## Initial Model: SIR
It's common to liken drug use to disease, treating drug addiction as an infection that can be recovered from. Using this analogy, we began looking into how diseases are modeled and how we can adapt this model to fit drug usage.
One of the simplest drug models is the SIR model, a compartment model based on the concept of mass action that sees infections as caused by interactions between infected people and susceptible people.
There are a few reasons that this model is good fit to begin modeling drug use:
Firstly, this model is very simple and easily adaptable to extra compartments or conditions on transfer.
Secondly, since we are looking at drug use in a population, relying on mass action rather than discrete modeling allows us to simplify the model.
Thirdly, the idea that addiction is caused by individuals interacting seems to be a good assumption for drug use as you would expect people to become addicted by being around other people with the drug.

One divergence we made from the most basic SIR model is allowing for relapse from the recovered group back into the infected group. This represents how recovering addicts will become addicted again at a different rate to people who have never used the drug before. However, we never move people back into the suseptible group as addiction is said to be 'lifelong'.

The SIR model can be defined with the following equations:
$$\frac{dS}{dt} = -\pi_1 * S * I $$
$$\frac{dI}{dt} = \pi_1 * S * I + \pi_2 * R * I - \pi_3 *  I $$
$$\frac{dR}{dt} = -\pi_2 * R * I + \pi_3 * I $$

With the parameters $\pi_1$,$\pi_2$ and $\pi_3$ representing the 'infectiosness' of the drug for susceptible people, the infectioness for recovering people and the rate of recovery for the drug respecivley.

We can now look at some plots to see how this model plays out for various combinations of parameters:

```{python, echo = FALSE, fig1, fig.show="hold", out.width="50%" }
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def SIR(p1,p2,p3,S0,I0,R0,i):

    vect_initial = np.array([S0,I0,R0]).T # vector of day index, suseptable, infected and recovered people
    
    output = pd.DataFrame(columns = ['day', 'S', 'I', 'R'])
    j = 0
    vect = vect_initial.copy()
    
    while j < i:
        vectplus1 = np.zeros([3])
        S = vect[0]
        I = vect[1]
        R = vect[2]
        vectplus1[0] = S - p1 *S*I
        vectplus1[1] = I +p1 *S*I + p2*R*I - p3*I
        vectplus1[2] = R - p2*R*I + p3*I
        output.loc[j] = np.concatenate((np.array([j]),vectplus1.T))
        vect = vectplus1.copy()
        j+=1
    					
    plt.plot(output['day'],output['S'])
    plt.plot(output['day'],output['I'])
    plt.plot(output['day'],output['R'])
    plt.title('p1=' + str(p1) + ', p2=' + str(p2) + ', p3=' +str(p3))
    plt.legend(['S','I','R'])
    plt.show()
   
SIR(0.001,0.02,0,70,20,10,100)
SIR(0.009, 0, 0.04, 70, 20,10,100)
SIR(0.001,0.05,0.5,70,20,10, 100)
SIR(0.0001,0.001, 0.1, 70,20,10,100)

```

## SUAR Model
The SIR model fails to distingush between different severities of addiction. By grouping anyone who is trying the drug once to people who are addicteed in the same group we are failing to capture the behaviour of people trying the drug without becoming reliant on the drug.
Because of this, we adapted the SIR model, renaming the infected group to addicted  and adding in a new group for users of the drug who are not addicted, labeled as the 'Using' group. Suseptible people will now move into the Using group before moving into the addicted group. Since there are now two groups who are using the drug and interacting with the community, the $I$ terms in the ODEs desribing the SIR now have to be replaced with $U+A$

The new model can now be described with the folowing equations:

$$\frac{dS}{dt} = - \pi_1*S*(A+U) + \pi_2*U   $$
$$\frac{dU}{dt} =  \pi_1*S*(A+U) - \pi_2*U  - \pi_3*U $$
$$\frac{dA}{dt} = \pi_3*U +\pi_4 *(A+U)*R - \pi_5*A $$
$$\frac{dR}{dt} =  \pi_5*A - \pi_4 *(A+U)*R $$

With parameters  $\pi_1$, $\pi_2$,  $\pi_3$, $\pi_4$, and $\pi_5$ being the 'infectivness' of the drug for suseptible people, the rate that people stop trying the drug, the rate that people bome addicted, the 'infectiveess' for recovered people and the recovery rate for addicted people respectivley.

```{python, echo = FALSE, fig2, fig.show="hold", out.width="50%" }
def SUAR(p1,p2,p3, p4, p5 ,S0,U0,A0,R0,i):

    vect_initial = np.array([S0,U0,A0,R0]).T # vector of day index, suseptable, infected and recovered people
    
    output = pd.DataFrame(columns = ['day', 'S', 'U','A', 'R'])
    j = 0
    vect = vect_initial.copy()
    
    while j < i:
        vectplus1 = np.zeros([4])
        S = vect[0]
        U = vect[1]
        A = vect[2]
        R = vect[3]
        vectplus1[0] = S -p1*S*(A+U) + p2*U
        vectplus1[1] = U +p1*S*(A+U) - p2*U - p3*U
        vectplus1[2] = A +p3*U + p4*(A+U)*R - p5*A
        vectplus1[3] = R + p5*A -p4*(A+U)*R
        output.loc[j] = np.concatenate((np.array([j]),vectplus1.T))
        vect = vectplus1.copy()
        j+=1
    					
    plt.plot(output['day'],output['S'])
    plt.plot(output['day'],output['U'])
    plt.plot(output['day'],output['A'])
    plt.plot(output['day'],output['R'])
    plt.title('p1=' + str(p1) + ', p2=' + str(p2) + ', p3=' +str(p3) + ', p4=' +str(p4) + ', p5=' +str(p5))
    plt.legend(['S','U','A','R'])
    plt.show()
   
SUAR(0.01,0.001,0.001, 0.001, 0.001 ,60,20,10,10,100)
SUAR(0.001,0.01,0.001, 0.001, 0.001 ,60,20,10,10,100)
SUAR(0.001,0.001,0.01, 0.001, 0.001 ,60,20,10,10,100)
SUAR(0.001,0.001,0.001, 0.01, 0.001 ,60,20,10,10,100)


```

## SUAR Model with age
Looking at the stationary points of the previous two models (see appendix for derivation), the only long term behaviour is to either kill off the drug and have no users or addicted people or have eveyone in the addicted or recovered group. However, this behaviour is not consistent with what we see in the real world, where we have a consitent number of people using and addicted to the drug, and a consistently high number of people who are suseptible to the drug. To fix we add age groups into the model, grouping them as children, teens, young adults, adults and seniors. Each of these groups have a distinct rate of death and births are porportioal to the number of young adults and adults. Seperating these groups also allows us to set different parameters according to each age group, capturing more nuanced beahviours such as more experiementation in young people.

Another feture we wanted to tackle is how people recover. In the same way that people start using drugs based on interactions with others who are using the drug, we expect people to recover based on interactions with people who aren't using the drug. This can be represented by support groups, concered parents or friends. Furthermore, we can expect people in one agegroup to be influence by different ammoint from each agregreoup. We can store this information with a matrix $I$, where $I_{ij}$ is the magnitude of the influence that group j has on group i.
We can now go in to further simplify this by defining two new terms, the positive and negitive influence on a age group $i$, to be:
$$P_i = \sum{k=1}{5}{I_{ik} * (S_k + R_K)}$$
$$N_i = \sum{k=1}{5}{I_{ik} * (U_k + A_K)}$$

The model now has 20 compartments with both sideways movment within age groups and downwards movement as people age.

Looking across age group 'i', the model can be described as:

$$\frac{dS_i}{dt} = aS_{i-1} + aU_{i-1} \pi_{i-1,2}P_{i-1} - S_i\pi_{i,1}N_i + (1-a)U_i\pi_{i,2}P_i - aSi - d_{i,s}S_i + (b\sum_{k=2}^{3}S_k+U_k+A_k+R_K | i = 0)  $$
$$\frac{dU_i}{dt} =  aS_{i-1}\pi_{i-1,1}N_{i-1} + aU_{i-1} - U_i * \pi_{i,3} - a U_i - U_i\pi_{i,2}P_i + (1-a)S_i\pi_{i,1}N_i - d_{i,U}U_i$$
$$\frac{dA_i}{dt} = aU_{i-1}\pi_{i-1,3} + aA_{i-1} + aR_{i-1}\pi_{i-1,4}N_{i-1} - A_i\pi_{i.5}P_i + (1-a)R_i\pi_{i,4}N_{i}-aA_i + (1-a)U_i\pi_{i,3}- d_{i,A}A_i$$
$$\frac{dR_i}{dt} = aA_{i-1}\pi_{i-1,5}P_{i-1} + aR_{i-1} - aR_i -R_i\pi_{i,4}N_i + (1-a)A_i\pi_{i,5}P_i - d_{i,R}R_I $$

With the paramers being sroted in matrices $\pi$, {d} and {i}, containing row-wise versions of the parameters for the SUAR model, the death rate for each comaprtment, and the influecne each age group has on the other, and scalars $a$ and $b$, which define the aging rate and the birth rate of the population.


```{python, echo = FALSE, fig3, fig.show="hold", out.width="50%"  }

def SUAR_20(aging_rate,birth_rate,death_rate, I, P, X0, steps):

    C = pd.DataFrame(columns=['s', 't', 'a', 'r'], dtype='float128')
    T = pd.DataFrame(columns=['s', 't', 'a', 'r'], dtype='float128')
    Y = pd.DataFrame(columns=['s', 't', 'a', 'r'], dtype='float128')
    A = pd.DataFrame(columns=['s', 't', 'a', 'r'], dtype='float128')
    S = pd.DataFrame(columns=['s', 't', 'a', 'r'], dtype='float128')
    
    (n_age_groups, n_status) = np.shape(X0)
    itterations  = 0
    while itterations < steps:
        C.loc[itterations] = X0[0]
        T.loc[itterations] = X0[1]
        Y.loc[itterations] = X0[2]
        A.loc[itterations] = X0[3]
        S.loc[itterations] = X0[4]
    
        i = 0
    
        IE = np.matmul(I, X0)
    
        Xn = np.zeros(np.shape(X0))
    
        while i < n_age_groups:
                group_vect = X0[i].copy()
                s = group_vect[0]
                t = group_vect[1]
                a = group_vect[2]
                r = group_vect[3]
                interaction_neg = np.sum(IE[i][[1, 2]])
                interaction_pos = np.sum(IE[i][[0, 3]])
    
                Xn[i][0] = s - (s * P[i][0] * interaction_neg) + t * P[i][1] * interaction_pos
                Xn[i][1] = t + (s * P[i][0] * interaction_neg) - t * P[i][1] * interaction_pos - t * P[i][2]
                Xn[i][2] = a + t * P[i][2] + r * P[i][3] * interaction_neg - a * P[i][4] * interaction_pos
                Xn[i][3] = r - r * P[i][3] * interaction_neg + a * P[i][4] * interaction_pos
    
                i += 1
    
        Xn_aged = np.zeros(np.shape(X0))
    
        i = 0
        j = 0
    
        while i < n_age_groups:
                j = 0
                while j < n_status:
                     if i == 0:
                            if j == 0:
                                Xn_aged[i][j] = Xn[i][j] * (1 - aging_rate - death_rate[i][j]) + birth_rate * sum(Xn[2] + Xn[3])
                            else:
                                Xn_aged[i][j] = Xn[i][j] * (1 - aging_rate - death_rate[i][j])
                     else:
                            Xn_aged[i][j] = Xn[i][j] * (1 - aging_rate - death_rate[i][j]) + X0[i - 1][j] * aging_rate
                     j += 1
                i += 1
        X0 = Xn_aged
        itterations += 1
    
    
    plt.plot(A.index.values,C['s'])
    plt.plot(A.index.values,C['t'])
    plt.plot(A.index.values,C['a'])
    plt.plot(A.index.values,C['r'])
    plt.plot(A.index.values,T['s'])
    plt.plot(A.index.values,T['t'])
    plt.plot(A.index.values,T['a'])
    plt.plot(A.index.values,T['r'])
    plt.plot(A.index.values,Y['s'])
    plt.plot(A.index.values,Y['t'])
    plt.plot(A.index.values,Y['a'])
    plt.plot(A.index.values,Y['r'])
    plt.plot(A.index.values,A['s'])
    plt.plot(A.index.values,A['t'])
    plt.plot(A.index.values,A['a'])
    plt.plot(A.index.values,S['r'])
    plt.plot(A.index.values,S['s'])
    plt.plot(A.index.values,S['t'])
    plt.plot(A.index.values,S['a'])
    plt.plot(A.index.values,S['r'])
    plt.title("Raw Populations") 
    plt.show()
    
    plt.title("Population Portions")
    pop = C['s']+T['s']+Y['s']+A['s']+S['s'] + C['t']+T['t']+Y['t']+A['t']+S['t'] + C['a']+T['a']+Y['a']+A['a']+S['a'] + C['r']+T['r']+Y['r']+A['r']+S['r']
    plt.plot(A.index.values,(C['s']+T['s']+Y['s']+A['s']+S['s'])/pop)
    plt.plot(A.index.values,(C['t']+T['t']+Y['t']+A['t']+S['t'])/pop)
    plt.plot(A.index.values,(C['a']+T['a']+Y['a']+A['a']+S['a'])/pop)
    plt.plot(A.index.values,(C['r']+T['r']+Y['r']+A['r']+S['r'])/pop)
    plt.legend(['S','U','A','R'])
    plt.show()
    
aging_rate = 0.05
birth_rate = 0.07
death_rate = 0.1*np.array([[0.2, 0.2, 0.2, 0.2],
                           [0.05, 0.05, 0.05, 0.05],
		           [0.1, 0.1, 0.1, 0.1],
			   [0.2, 0.2, 0.2, 0.2],
			   [0.5, 0.5, 0.5, 0.5]])

X0 = 100 * np.array([[5, 0, 0, 0],
                     [10, 10, 0, 0],
		     [10, 5, 5, 0],
		     [10, 20, 0, 0],
		     [10, 0, 0, 0]])

(n_age_groups, n_status) = np.shape(X0)

I =  0.001*np.array([[0.1, 0.0, 0.2, 0.5, 0.2],
                     [0.0, 0.5, 0.2, 0.2, 0.1],
                     [0.0, 0.1, 0.7, 0.2, 0.0],
                     [0.0, 0.0, 0.1, 0.8, 0.1],
                     [0.0, 0.0, 0.0, 0.5, 0.5]])

P = 0.1*np.array([[0.0, 1.0, 0.5, 0.0, 1.0],
                  [0.5, 0.5, 0.5, 0.8, 0.2],
                  [0.5, 0.5, 0.5, 0.6, 0.2],
                  [0.1, 0.1, 0.5, 0.6, 0.1],
                  [0.0, 0.0, 0.5, 0.9, 0.1]])

SUAR_20(aging_rate,birth_rate,death_rate, I, P, X0,650)

```

## Simplified SUAR Model with age
After building the SUAR model with different age groups, we toyed arroung with various combinations of paramenters to see how the model reacted. 
However, we found that with 20 compartments and 73 parameters, it is realy hard to go through all the combinations to find meaningfull results from the model. We could see that there were stationary points for the population portions, but finding them analyticaly was near impossible. Because of this, we sought to find a way to simplify the model to produce results that are easier to understand. We did this by removing the different age groups all together, while keeping the equations describing the model the same. By removing the age groups, the equations dramaticaly simplify into this form;

              
$$\frac{dS}{dt} = -S\pi_{1}N +U\pi_2P  -d_SS + b(S+U+A+R)  $$
$$\frac{dU}{dt} = S\pi_1N -U\pi_2P - U\pi_3 - d_UU  $$
$$\frac{dA}{dt} = U\pi_3 - A\pi_4P + R\pi_5N - d_AA$$
$$\frac{dR}{dt} = A\pi_4P - R\pi_5N - d_RR $$

```{python, echo = FALSE, fig4, fig.show="hold", out.width="50%" }
def SUAR_5(p1,p2,p3, p4, p5,b,d,S0,U0,A0,R0,i):

    vect_initial = np.array([S0,U0,A0,R0]).T # vector of day index, suseptable, infected and recovered people
    
    output = pd.DataFrame(columns = ['day', 'S', 'U','A', 'R'])
    j = 0
    vect = vect_initial.copy()
    
    while j < i:
        vectplus1 = np.zeros([4])
        S = vect[0]
        U = vect[1]
        A = vect[2]
        R = vect[3]
        vectplus1[0] = S - p1*S*(A+U) + p2*U*(S+R)  - d[0]*S + b*(S+U+A+R) 
        vectplus1[1] = U + p1*S*(A+U) - p2*U*(S+R) - p3*U - d[1]*U
        vectplus1[2] = A + p3*U + p4*(A+U)*R - p5*A*(R+S) - d[2]*A
        vectplus1[3] = R + p5*A*(S+R) - p4*(A+U)*R - d[3]*R

        output.loc[j] = np.concatenate((np.array([j]),vectplus1.T))
        vect = vectplus1.copy()
        j+=1
    output['pop'] = output['S'] + output['U'] + output['A'] + output['R']
    plt.plot(output['day'],output['S']/output['pop'])
    plt.plot(output['day'],output['U']/output['pop'])
    plt.plot(output['day'],output['A']/output['pop'])
    plt.plot(output['day'],output['R']/output['pop'])
    plt.title('Portion: p1=' + str(p1) + ', p2=' + str(p2) + ', p3=' +str(p3) + ', p4=' +str(p4) + ', p5=' +str(p5))
    plt.legend(['S','U','A','R'])
    plt.show()


SUAR_5(0.01,0.001,0.001, 0.001, 0.001,0.001,[0.0001,0.0005,0.001,0.0001] ,60,20,10,10,300)
SUAR_5(0.001,0.01,0.001, 0.001, 0.001,0.001,[0.0001,0.0005,0.001,0.0001],60,20,10,10,300)
SUAR_5(0.001,0.001,0.01, 0.001, 0.001,0.001,[0.0001,0.0005,0.001,0.0001],60,20,10,10,300)
SUAR_5(0.001,0.001,0.001, 0.01, 0.001,0.001,[0.0001,0.0005,0.001,0.0001],60,20,10,10,300)
SUAR_5(0.001,0.001,0.001, 0.001, 0.01,0.001,[0.0001,0.0005,0.001,0.0001],60,20,10,10,300)
SUAR_5(0.001,0.001,0.001, 0.001, 0.001,0.001,[0.0001,0.0005,0.001,0.0001],60,20,10,10,300)
```
\newpage

# Results

// Stationay distributions of final model -> jacobian plot

\newpage

# Discussion

// Compare our model
// Insparations
// Limitaion
// Future stuff

\newpage

# Connclution

// Conclution


\newpage
# Appendix

## Appendix 1 : Stationary points of SIR model

$$0 = -\pi_1 * S * I $$
$$0 = \pi_1 * S * I + \pi_2 * R * I - \pi_3 *  I $$
$$0 = -\pi_2 * R * I + \pi_3 * I $$

Therefore either $\pi_1$, $S$ or $I$ must be 0

If $I = 0$:

$$0 = -\pi_1 * S * 0 $$
$$0 = \pi_1 * S * 0 + \pi_2 * R * 0 - \pi_3 *  0 $$
$$0 = -\pi_2 * R * 0 + \pi_3 * 0 $$

Therefore any point [$S$,0,$R$] is stationary.

If $\pi_1 = 0$ or $S=0$:

$$0 =  0 * I $$
$$0 = 0 * I + \pi_2 * R * I - \pi_3 *  I $$
$$0 = -\pi_2 * R * I + \pi_3 * I $$

Therefore:

$$ \pi_2 * R * I - \pi_3 *  I = - \pi_2 * R * I + \pi_3 *  I  $$
$$ \pi_2 * R * I = \pi_3 * I $$
$$ R:I = \pi_3:\pi_2 $$

Therefore any point [0, $\frac {P_{total}*\pi_2}{\pi_2 + \pi_3}$ ,$\frac {P_{total}*\pi_3}{\pi_2 + \pi_3}$]

## Appendix 2 : Stationary points of SUAR

$$0 = - \pi_1*S*(A+U) + \pi_2*U   $$
$$0 =  \pi_1*S*(A+U) - \pi_2*U  - \pi_3*U $$
$$0 = \pi_3*U +\pi_4 *(A+U)*R - \pi_5*A $$
$$0 =  \pi_5*A - \pi_4 *(A+U)*R $$

By combing the first two and last two equations, one can see that if the parameters are non 0, $U=0$. Therefore:

$$ 0 = \pi_1*S*A $$
$$0 = \pi_4 *A*R - \pi_5*A $$
$$0 =  \pi_5*A - \pi_4 *A*R $$

Therefore $S = 0$ or $A = 0$
In the case $A = 0$, any point [$S$,0,0,$R$] will be stationary

In the case $S=0$
$$ \pi_4*A*R = \pi_5*A$$
$$R:A = \pi_5:\pi_4$$

Therefore any point [0,0, $\frac {P_{total}*\pi_4}{\pi_4 + \pi_5}$ ,$\frac {P_{total}*\pi_5}{\pi_4 + \pi_5}$]
